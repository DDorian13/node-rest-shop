{"ast":null,"code":"import customKeysDataProvider from 'ra-data-rest-client';\nimport { fetchUtils } from \"react-admin\";\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) {\n    options.headers = new Headers({\n      Accept: '*/*'\n    });\n  }\n\n  const token = JSON.parse(localStorage.getItem('token'));\n  options.headers.set('Authorization', `Bearer ${token}`);\n  return fetchUtils.fetchJson(url, options);\n};\n\nconst customKeysHash = {\n  'products': '_id',\n  'orders': '_id',\n  'users': '_id'\n};\nconst dataProvider = customKeysDataProvider('http://localhost:5000', customKeysHash, {}, httpClient);\nconst myDataProvider = { ...dataProvider,\n  update: (resource, params) => {\n    if (resource !== 'products' || !params.models.product.productImage) {\n      // fallback to the default implementation\n      return dataProvider.update(resource, params);\n    }\n    /**\r\n     * For posts update only, convert uploaded image in base 64 and attach it to\r\n     * the `picture` sent property, with `src` and `title` attributes.\r\n     */\n    // Freshly dropped pictures are File objects and must be converted to base64 strings\n\n\n    const newPictures = params.models.product.productImage.filter(p => p.rawFile instanceof File);\n    const formerPictures = params.models.product.productImage.filter(p => !(p.rawFile instanceof File));\n    return Promise.all(newPictures.map(convertFileToBase64)).then(base64Pictures => base64Pictures.map(picture64 => ({\n      productImage: picture64\n    }))).then(transformedNewPictures => dataProvider.update(resource, { ...params,\n      product: { ...params.product,\n        productImage: [...transformedNewPictures, ...formerPictures]\n      }\n    }));\n  }\n};\n/**\r\n * Convert a `File` object returned by the upload input into a base 64 string.\r\n * That's not the most optimized way to store images in production, but it's\r\n * enough to illustrate the idea of data provider decoration.\r\n */\n\nconst convertFileToBase64 = file => new Promise((resolve, reject) => {\n  const reader = new FileReader();\n\n  reader.onload = () => resolve(reader.result);\n\n  reader.onerror = reject;\n  reader.readAsDataURL(file.rawFile);\n});\n\nexport default myDataProvider;","map":{"version":3,"sources":["C:/Users/Dávid Dorián/Egyetem/5. félév/Témalabor/AndroidLibrary/node-rest-shop/client/src/addUploadFeature.js"],"names":["customKeysDataProvider","fetchUtils","httpClient","url","options","headers","Headers","Accept","token","JSON","parse","localStorage","getItem","set","fetchJson","customKeysHash","dataProvider","myDataProvider","update","resource","params","models","product","productImage","newPictures","filter","p","rawFile","File","formerPictures","Promise","all","map","convertFileToBase64","then","base64Pictures","picture64","transformedNewPictures","file","resolve","reject","reader","FileReader","onload","result","onerror","readAsDataURL"],"mappings":"AAAA,OAAOA,sBAAP,MAAmC,qBAAnC;AACA,SAAQC,UAAR,QAAyB,aAAzB;;AAEA,MAAMC,UAAU,GAAG,CAACC,GAAD,EAAMC,OAAO,GAAG,EAAhB,KAAuB;AACtC,MAAI,CAACA,OAAO,CAACC,OAAb,EAAsB;AAClBD,IAAAA,OAAO,CAACC,OAAR,GAAkB,IAAIC,OAAJ,CAAY;AAAEC,MAAAA,MAAM,EAAE;AAAV,KAAZ,CAAlB;AACH;;AACD,QAAMC,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWC,YAAY,CAACC,OAAb,CAAqB,OAArB,CAAX,CAAd;AACAR,EAAAA,OAAO,CAACC,OAAR,CAAgBQ,GAAhB,CAAoB,eAApB,EAAsC,UAASL,KAAM,EAArD;AACA,SAAOP,UAAU,CAACa,SAAX,CAAqBX,GAArB,EAA0BC,OAA1B,CAAP;AACH,CAPD;;AASA,MAAMW,cAAc,GAAG;AACnB,cAAY,KADO;AAEnB,YAAU,KAFS;AAGnB,WAAS;AAHU,CAAvB;AAMA,MAAMC,YAAY,GAAGhB,sBAAsB,CAAC,uBAAD,EAA0Be,cAA1B,EAA0C,EAA1C,EAA8Cb,UAA9C,CAA3C;AAEA,MAAMe,cAAc,GAAG,EACnB,GAAGD,YADgB;AAEnBE,EAAAA,MAAM,EAAE,CAACC,QAAD,EAAWC,MAAX,KAAsB;AAC1B,QAAID,QAAQ,KAAK,UAAb,IAA2B,CAACC,MAAM,CAACC,MAAP,CAAcC,OAAd,CAAsBC,YAAtD,EAAoE;AAChE;AACA,aAAOP,YAAY,CAACE,MAAb,CAAoBC,QAApB,EAA8BC,MAA9B,CAAP;AACH;AACD;;;;AAKI;;;AACJ,UAAMI,WAAW,GAAGJ,MAAM,CAACC,MAAP,CAAcC,OAAd,CAAsBC,YAAtB,CAAmCE,MAAnC,CAChBC,CAAC,IAAIA,CAAC,CAACC,OAAF,YAAqBC,IADV,CAApB;AAGA,UAAMC,cAAc,GAAGT,MAAM,CAACC,MAAP,CAAcC,OAAd,CAAsBC,YAAtB,CAAmCE,MAAnC,CACnBC,CAAC,IAAI,EAAEA,CAAC,CAACC,OAAF,YAAqBC,IAAvB,CADc,CAAvB;AAIA,WAAOE,OAAO,CAACC,GAAR,CAAYP,WAAW,CAACQ,GAAZ,CAAgBC,mBAAhB,CAAZ,EACFC,IADE,CACGC,cAAc,IAChBA,cAAc,CAACH,GAAf,CAAmBI,SAAS,KAAK;AAC7Bb,MAAAA,YAAY,EAAEa;AADe,KAAL,CAA5B,CAFD,EAMFF,IANE,CAMGG,sBAAsB,IACxBrB,YAAY,CAACE,MAAb,CAAoBC,QAApB,EAA8B,EAC1B,GAAGC,MADuB;AAE1BE,MAAAA,OAAO,EAAE,EACL,GAAGF,MAAM,CAACE,OADL;AAELC,QAAAA,YAAY,EAAE,CACV,GAAGc,sBADO,EAEV,GAAGR,cAFO;AAFT;AAFiB,KAA9B,CAPD,CAAP;AAkBH;AAtCkB,CAAvB;AAyCA;;;;;;AAKA,MAAMI,mBAAmB,GAAGK,IAAI,IAC5B,IAAIR,OAAJ,CAAY,CAACS,OAAD,EAAUC,MAAV,KAAqB;AAC7B,QAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;;AACAD,EAAAA,MAAM,CAACE,MAAP,GAAgB,MAAMJ,OAAO,CAACE,MAAM,CAACG,MAAR,CAA7B;;AACAH,EAAAA,MAAM,CAACI,OAAP,GAAiBL,MAAjB;AAEAC,EAAAA,MAAM,CAACK,aAAP,CAAqBR,IAAI,CAACX,OAA1B;AACH,CAND,CADJ;;AASA,eAAeV,cAAf","sourcesContent":["import customKeysDataProvider from 'ra-data-rest-client';\r\nimport {fetchUtils} from \"react-admin\";\r\n\r\nconst httpClient = (url, options = {}) => {\r\n    if (!options.headers) {\r\n        options.headers = new Headers({ Accept: '*/*' });\r\n    }\r\n    const token = JSON.parse(localStorage.getItem('token'));\r\n    options.headers.set('Authorization', `Bearer ${token}`);\r\n    return fetchUtils.fetchJson(url, options);\r\n};\r\n\r\nconst customKeysHash = {\r\n    'products': '_id',\r\n    'orders': '_id',\r\n    'users': '_id'\r\n}\r\n\r\nconst dataProvider = customKeysDataProvider('http://localhost:5000', customKeysHash, {}, httpClient);\r\n\r\nconst myDataProvider = {\r\n    ...dataProvider,\r\n    update: (resource, params) => {\r\n        if (resource !== 'products' || !params.models.product.productImage) {\r\n            // fallback to the default implementation\r\n            return dataProvider.update(resource, params);\r\n        }\r\n        /**\r\n         * For posts update only, convert uploaded image in base 64 and attach it to\r\n         * the `picture` sent property, with `src` and `title` attributes.\r\n         */\r\n\r\n            // Freshly dropped pictures are File objects and must be converted to base64 strings\r\n        const newPictures = params.models.product.productImage.filter(\r\n            p => p.rawFile instanceof File\r\n            );\r\n        const formerPictures = params.models.product.productImage.filter(\r\n            p => !(p.rawFile instanceof File)\r\n        );\r\n\r\n        return Promise.all(newPictures.map(convertFileToBase64))\r\n            .then(base64Pictures =>\r\n                base64Pictures.map(picture64 => ({\r\n                    productImage: picture64\r\n                }))\r\n            )\r\n            .then(transformedNewPictures =>\r\n                dataProvider.update(resource, {\r\n                    ...params,\r\n                    product: {\r\n                        ...params.product,\r\n                        productImage: [\r\n                            ...transformedNewPictures,\r\n                            ...formerPictures,\r\n                        ],\r\n                    },\r\n                })\r\n            );\r\n    },\r\n};\r\n\r\n/**\r\n * Convert a `File` object returned by the upload input into a base 64 string.\r\n * That's not the most optimized way to store images in production, but it's\r\n * enough to illustrate the idea of data provider decoration.\r\n */\r\nconst convertFileToBase64 = file =>\r\n    new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = () => resolve(reader.result);\r\n        reader.onerror = reject;\r\n\r\n        reader.readAsDataURL(file.rawFile);\r\n    });\r\n\r\nexport default myDataProvider;"]},"metadata":{},"sourceType":"module"}