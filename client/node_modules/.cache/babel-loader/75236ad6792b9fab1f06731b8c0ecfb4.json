{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { useMemo } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useEffect } from 'react';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = {\n  action: CRUD_GET_MANY\n};\n/**\r\n * Call the dataProvider.getMany() method and return the resolved result\r\n * as well as the loading state.\r\n *\r\n * The return value updates according to the request state:\r\n *\r\n * - start: { loading: true, loaded: false }\r\n * - success: { data: [data from response], loading: false, loaded: true }\r\n * - error: { error: [error from response], loading: false, loaded: true }\r\n *\r\n * This hook will return the cached result when called a second time\r\n * with the same parameters, until the response arrives.\r\n *\r\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\r\n *\r\n * useGetMany('tags', [1, 2, 3]);\r\n * useGetMany('tags', [3, 4]);\r\n *\r\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\r\n *\r\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\r\n *\r\n * @param resource The resource name, e.g. 'posts'\r\n * @param ids The resource identifiers, e.g. [123, 456, 789]\r\n * @param options Options object to pass to the dataProvider. May include side effects to be executed upon success or failure, e.g. { onSuccess: { refresh: true } }\r\n *\r\n * @returns The current request state. Destructure as { data, error, loading, loaded }.\r\n *\r\n * @example\r\n *\r\n * import { useGetMany } from 'react-admin';\r\n *\r\n * const PostTags = ({ record }) => {\r\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\r\n *     if (loading) { return <Loading />; }\r\n *     if (error) { return <p>ERROR</p>; }\r\n *     return (\r\n *          <ul>\r\n *              {data.map(tag => (\r\n *                  <li key={tag.id}>{tag.name}</li>\r\n *              ))}\r\n *          </ul>\r\n *      );\r\n * };\r\n */\n\nvar useGetMany = function (resource, ids, options) {\n  if (options === void 0) {\n    options = {};\n  } // we can't use useQueryWithStore here because we're aggregating queries first\n  // therefore part of the useQueryWithStore logic will have to be repeated below\n\n\n  var selectMany = useMemo(makeGetManySelector, []);\n  var data = useSelector(function (state) {\n    return selectMany(state, resource, ids);\n  });\n\n  var _a = useSafeSetState({\n    data: data,\n    error: null,\n    loading: ids.length !== 0,\n    loaded: ids.length === 0 || data.length !== 0 && !data.includes(undefined)\n  }),\n      state = _a[0],\n      setState = _a[1];\n\n  if (!isEqual(state.data, data)) {\n    setState(__assign(__assign({}, state), {\n      data: data,\n      loaded: true\n    }));\n  }\n\n  dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n\n  useEffect(function () {\n    if (!queriesToCall[resource]) {\n      queriesToCall[resource] = [];\n    }\n    /**\r\n     * queriesToCall stores the queries to call under the following shape:\r\n     *\r\n     * {\r\n     *   'posts': [\r\n     *     { ids: [1, 2], setState }\r\n     *     { ids: [2, 3], setState, onSuccess }\r\n     *     { ids: [4, 5], setState }\r\n     *   ],\r\n     *   'comments': [\r\n     *     { ids: [345], setState, onFailure }\r\n     *   ]\r\n     * }\r\n     */\n\n\n    queriesToCall[resource] = queriesToCall[resource].concat({\n      ids: ids,\n      setState: setState,\n      onSuccess: options && options.onSuccess,\n      onFailure: options && options.onFailure\n    });\n    callQueries(); // debounced by lodash\n  }, [JSON.stringify({\n    resource: resource,\n    ids: ids,\n    options: options\n  }), dataProvider]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return state;\n};\n/**\r\n * Memoized selector for getting an array of resources based on an array of ids\r\n *\r\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\r\n */\n\n\nvar makeGetManySelector = function () {\n  return createSelector(function (state) {\n    return state.admin.resources;\n  }, function (_, resource) {\n    return resource;\n  }, function (_, __, ids) {\n    return ids;\n  }, function (resources, resource, ids) {\n    return resources[resource] ? ids.map(function (id) {\n      return resources[resource].data[id];\n    }) : ids.map(function (id) {\n      return undefined;\n    });\n  });\n};\n/**\r\n * Call the dataProvider once per resource\r\n */\n\n\nvar callQueries = debounce(function () {\n  var resources = Object.keys(queriesToCall);\n  resources.forEach(function (resource) {\n    var queries = __spreadArrays(queriesToCall[resource]); // cloning to avoid side effects\n\n    /**\r\n     * Extract ids from queries, aggregate and deduplicate them\r\n     *\r\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\r\n     */\n\n\n    var accumulatedIds = queries.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n\n    if (accumulatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      queries.forEach(function (_a) {\n        var ids = _a.ids,\n            setState = _a.setState,\n            onSuccess = _a.onSuccess;\n        setState({\n          data: emptyArray,\n          loading: false,\n          loaded: true\n        });\n\n        if (onSuccess) {\n          onSuccess({\n            data: emptyArray\n          });\n        }\n      });\n      return;\n    }\n\n    dataProvider.getMany(resource, {\n      ids: accumulatedIds\n    }, DataProviderOptions).then(function (response) {\n      // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var ids = _a.ids,\n              setState = _a.setState,\n              onSuccess = _a.onSuccess;\n          setState(function (prevState) {\n            return __assign(__assign({}, prevState), {\n              error: null,\n              loading: false,\n              loaded: true\n            });\n          });\n\n          if (onSuccess) {\n            var subData = ids.map(function (id) {\n              return response.data.find(function (datum) {\n                return datum.id == id;\n              });\n            } // eslint-disable-line eqeqeq\n            );\n            onSuccess({\n              data: subData\n            });\n          }\n        });\n      });\n    }).catch(function (error) {\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var setState = _a.setState,\n              onFailure = _a.onFailure;\n          setState({\n            error: error,\n            loading: false,\n            loaded: false\n          });\n          onFailure && onFailure(error);\n        });\n      });\n    });\n    delete queriesToCall[resource];\n  });\n});\nvar emptyArray = [];\nexport default useGetMany;","map":{"version":3,"sources":["C:/Users/Felhasználó/IdeaProjects/node-rest-shop/client/node_modules/ra-core/esm/dataProvider/useGetMany.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArrays","il","r","Array","k","a","j","jl","useMemo","ReactDOM","useSelector","createSelector","debounce","union","isEqual","CRUD_GET_MANY","useSafeSetState","useDataProvider","useEffect","queriesToCall","dataProvider","DataProviderOptions","action","useGetMany","resource","ids","options","selectMany","makeGetManySelector","data","state","_a","error","loading","loaded","includes","undefined","setState","concat","onSuccess","onFailure","callQueries","JSON","stringify","admin","resources","_","__","map","id","keys","forEach","queries","accumulatedIds","reduce","acc","filter","v","emptyArray","getMany","then","response","unstable_batchedUpdates","prevState","subData","find","datum","catch"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\nimport { useMemo } from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { useSelector } from 'react-redux';\r\nimport { createSelector } from 'reselect';\r\nimport debounce from 'lodash/debounce';\r\nimport union from 'lodash/union';\r\nimport isEqual from 'lodash/isEqual';\r\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\r\nimport { useSafeSetState } from '../util/hooks';\r\nimport useDataProvider from './useDataProvider';\r\nimport { useEffect } from 'react';\r\nvar queriesToCall = {};\r\nvar dataProvider;\r\nvar DataProviderOptions = { action: CRUD_GET_MANY };\r\n/**\r\n * Call the dataProvider.getMany() method and return the resolved result\r\n * as well as the loading state.\r\n *\r\n * The return value updates according to the request state:\r\n *\r\n * - start: { loading: true, loaded: false }\r\n * - success: { data: [data from response], loading: false, loaded: true }\r\n * - error: { error: [error from response], loading: false, loaded: true }\r\n *\r\n * This hook will return the cached result when called a second time\r\n * with the same parameters, until the response arrives.\r\n *\r\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\r\n *\r\n * useGetMany('tags', [1, 2, 3]);\r\n * useGetMany('tags', [3, 4]);\r\n *\r\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\r\n *\r\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\r\n *\r\n * @param resource The resource name, e.g. 'posts'\r\n * @param ids The resource identifiers, e.g. [123, 456, 789]\r\n * @param options Options object to pass to the dataProvider. May include side effects to be executed upon success or failure, e.g. { onSuccess: { refresh: true } }\r\n *\r\n * @returns The current request state. Destructure as { data, error, loading, loaded }.\r\n *\r\n * @example\r\n *\r\n * import { useGetMany } from 'react-admin';\r\n *\r\n * const PostTags = ({ record }) => {\r\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\r\n *     if (loading) { return <Loading />; }\r\n *     if (error) { return <p>ERROR</p>; }\r\n *     return (\r\n *          <ul>\r\n *              {data.map(tag => (\r\n *                  <li key={tag.id}>{tag.name}</li>\r\n *              ))}\r\n *          </ul>\r\n *      );\r\n * };\r\n */\r\nvar useGetMany = function (resource, ids, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // we can't use useQueryWithStore here because we're aggregating queries first\r\n    // therefore part of the useQueryWithStore logic will have to be repeated below\r\n    var selectMany = useMemo(makeGetManySelector, []);\r\n    var data = useSelector(function (state) {\r\n        return selectMany(state, resource, ids);\r\n    });\r\n    var _a = useSafeSetState({\r\n        data: data,\r\n        error: null,\r\n        loading: ids.length !== 0,\r\n        loaded: ids.length === 0 ||\r\n            (data.length !== 0 && !data.includes(undefined)),\r\n    }), state = _a[0], setState = _a[1];\r\n    if (!isEqual(state.data, data)) {\r\n        setState(__assign(__assign({}, state), { data: data, loaded: true }));\r\n    }\r\n    dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\r\n    useEffect(function () {\r\n        if (!queriesToCall[resource]) {\r\n            queriesToCall[resource] = [];\r\n        }\r\n        /**\r\n         * queriesToCall stores the queries to call under the following shape:\r\n         *\r\n         * {\r\n         *   'posts': [\r\n         *     { ids: [1, 2], setState }\r\n         *     { ids: [2, 3], setState, onSuccess }\r\n         *     { ids: [4, 5], setState }\r\n         *   ],\r\n         *   'comments': [\r\n         *     { ids: [345], setState, onFailure }\r\n         *   ]\r\n         * }\r\n         */\r\n        queriesToCall[resource] = queriesToCall[resource].concat({\r\n            ids: ids,\r\n            setState: setState,\r\n            onSuccess: options && options.onSuccess,\r\n            onFailure: options && options.onFailure,\r\n        });\r\n        callQueries(); // debounced by lodash\r\n    }, [JSON.stringify({ resource: resource, ids: ids, options: options }), dataProvider]); // eslint-disable-line react-hooks/exhaustive-deps\r\n    return state;\r\n};\r\n/**\r\n * Memoized selector for getting an array of resources based on an array of ids\r\n *\r\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\r\n */\r\nvar makeGetManySelector = function () {\r\n    return createSelector(function (state) { return state.admin.resources; }, function (_, resource) { return resource; }, function (_, __, ids) { return ids; }, function (resources, resource, ids) {\r\n        return resources[resource]\r\n            ? ids.map(function (id) { return resources[resource].data[id]; })\r\n            : ids.map(function (id) { return undefined; });\r\n    });\r\n};\r\n/**\r\n * Call the dataProvider once per resource\r\n */\r\nvar callQueries = debounce(function () {\r\n    var resources = Object.keys(queriesToCall);\r\n    resources.forEach(function (resource) {\r\n        var queries = __spreadArrays(queriesToCall[resource]); // cloning to avoid side effects\r\n        /**\r\n         * Extract ids from queries, aggregate and deduplicate them\r\n         *\r\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\r\n         */\r\n        var accumulatedIds = queries\r\n            .reduce(function (acc, _a) {\r\n            var ids = _a.ids;\r\n            return union(acc, ids);\r\n        }, []) // concat + unique\r\n            .filter(function (v) { return v != null && v !== ''; }); // remove null values\r\n        if (accumulatedIds.length === 0) {\r\n            // no need to call the data provider if all the ids are null\r\n            queries.forEach(function (_a) {\r\n                var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\r\n                setState({\r\n                    data: emptyArray,\r\n                    loading: false,\r\n                    loaded: true,\r\n                });\r\n                if (onSuccess) {\r\n                    onSuccess({ data: emptyArray });\r\n                }\r\n            });\r\n            return;\r\n        }\r\n        dataProvider\r\n            .getMany(resource, { ids: accumulatedIds }, DataProviderOptions)\r\n            .then(function (response) {\r\n            // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\r\n            return ReactDOM.unstable_batchedUpdates(function () {\r\n                return queries.forEach(function (_a) {\r\n                    var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\r\n                    setState(function (prevState) { return (__assign(__assign({}, prevState), { error: null, loading: false, loaded: true })); });\r\n                    if (onSuccess) {\r\n                        var subData = ids.map(function (id) {\r\n                            return response.data.find(function (datum) { return datum.id == id; });\r\n                        } // eslint-disable-line eqeqeq\r\n                        );\r\n                        onSuccess({ data: subData });\r\n                    }\r\n                });\r\n            });\r\n        })\r\n            .catch(function (error) {\r\n            return ReactDOM.unstable_batchedUpdates(function () {\r\n                return queries.forEach(function (_a) {\r\n                    var setState = _a.setState, onFailure = _a.onFailure;\r\n                    setState({ error: error, loading: false, loaded: false });\r\n                    onFailure && onFailure(error);\r\n                });\r\n            });\r\n        });\r\n        delete queriesToCall[resource];\r\n    });\r\n});\r\nvar emptyArray = [];\r\nexport default useGetMany;\r\n"]},"metadata":{},"sourceType":"module"}