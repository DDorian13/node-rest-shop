{"ast":null,"code":"// import customKeysDataProvider from 'ra-data-rest-client';\n// import {fetchUtils} from \"react-admin\";\n//\n// const httpClient = (url, options = {}) => {\n//     if (!options.headers) {\n//         options.headers = new Headers({ Accept: '*/*' });\n//     }\n//     const token = JSON.parse(localStorage.getItem('token'));\n//     options.headers.set('Authorization', `Bearer ${token}`);\n//     return fetchUtils.fetchJson(url, options);\n// };\n//\n// const customKeysHash = {\n//     'products': '_id',\n//     'orders': '_id',\n//     'users': '_id'\n// }\n//\n// const dataProvider = customKeysDataProvider('http://localhost:5000', customKeysHash, {}, httpClient);\n//\n// const myDataProvider = {\n//     ...dataProvider,\n//     post: (resource, params) => {\n//         if (resource !== 'products' || !params.models.product.productImage) {\n//             // fallback to the default implementation\n//             return dataProvider.create(resource, params);\n//         }\n//         /**\n//          * For posts update only, convert uploaded image in base 64 and attach it to\n//          * the `picture` sent property, with `src` and `title` attributes.\n//          */\n//\n//             // Freshly dropped pictures are File objects and must be converted to base64 strings\n//         const newPictures = params.models.product.productImage.filter(\n//             p => p.rawFile instanceof File\n//             );\n//         const formerPictures = params.models.product.productImage.filter(\n//             p => !(p.rawFile instanceof File)\n//         );\n//\n//         return Promise.all(newPictures.map(convertFileToBase64))\n//             .then(base64Pictures =>\n//                 base64Pictures.map(picture64 => ({\n//                     picture64\n//                 }))\n//             )\n//             .then(transformedNewPictures =>\n//                 dataProvider.create(resource, {\n//                     ...params,\n//                     product: {\n//                         ...params.product,\n//                         productImage: [\n//                             ...formerPictures,\n//                         ],\n//                     },\n//                 })\n//             );\n//     },\n// };\n//\n// /**\n//  * Convert a `File` object returned by the upload input into a base 64 string.\n//  * That's not the most optimized way to store images in production, but it's\n//  * enough to illustrate the idea of data provider decoration.\n//  */\n// const convertFileToBase64 = file =>\n//     new Promise((resolve, reject) => {\n//         const reader = new FileReader();\n//         reader.onload = () => resolve(reader.result);\n//         reader.onerror = reject;\n//\n//         reader.readAsDataURL(file.rawFile);\n//     });\n//\n// export default myDataProvider;\n//-----------------------------------------------------------------------------------------------------\n\n/**\r\n * Convert a `File` object returned by the upload input into\r\n * a base 64 string. That's easier to use on FakeRest, used on\r\n * the ng-admin example. But that's probably not the most optimized\r\n * way to do in a production database.\r\n */\nconst convertFileToBase64 = file => new Promise((resolve, reject) => {\n  const reader = new FileReader();\n  reader.readAsDataURL(file.rawFile);\n\n  reader.onload = () => resolve(reader.result);\n\n  reader.onerror = reject;\n});\n/**\r\n * For posts update only, convert uploaded image in base 64 and attach it to\r\n * the `picture` sent property, with `src` and `title` attributes.\r\n */\n\n\nconst addUploadCapabilities = requestHandler => (type, resource, params) => {\n  if (type === 'UPDATE' && resource === 'posts') {\n    if (params.data.pictures && params.data.pictures.length) {\n      // only freshly dropped pictures are instance of File\n      const formerPictures = params.data.pictures.filter(p => !(p.rawFile instanceof File));\n      const newPictures = params.data.pictures.filter(p => p.rawFile instanceof File);\n      return Promise.all(newPictures.map(convertFileToBase64)).then(base64Pictures => base64Pictures.map(picture64 => ({\n        src: picture64,\n        title: `${params.data.title}`\n      }))).then(transformedNewPictures => requestHandler(type, resource, { ...params,\n        data: { ...params.data,\n          pictures: [...transformedNewPictures, ...formerPictures]\n        }\n      }));\n    }\n  }\n\n  return requestHandler(type, resource, params);\n};\n\nexport default addUploadCapabilities;","map":{"version":3,"sources":["C:/Users/Dávid Dorián/Egyetem/5. félév/Témalabor/AndroidLibrary/node-rest-shop/client/src/addUploadFeature.js"],"names":["convertFileToBase64","file","Promise","resolve","reject","reader","FileReader","readAsDataURL","rawFile","onload","result","onerror","addUploadCapabilities","requestHandler","type","resource","params","data","pictures","length","formerPictures","filter","p","File","newPictures","all","map","then","base64Pictures","picture64","src","title","transformedNewPictures"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AACA;;;;;;AAMA,MAAMA,mBAAmB,GAAGC,IAAI,IAAI,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACjE,QAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;AACAD,EAAAA,MAAM,CAACE,aAAP,CAAqBN,IAAI,CAACO,OAA1B;;AAEAH,EAAAA,MAAM,CAACI,MAAP,GAAgB,MAAMN,OAAO,CAACE,MAAM,CAACK,MAAR,CAA7B;;AACAL,EAAAA,MAAM,CAACM,OAAP,GAAiBP,MAAjB;AACH,CANmC,CAApC;AAQA;;;;;;AAIA,MAAMQ,qBAAqB,GAAGC,cAAc,IAAI,CAACC,IAAD,EAAOC,QAAP,EAAiBC,MAAjB,KAA4B;AACxE,MAAIF,IAAI,KAAK,QAAT,IAAqBC,QAAQ,KAAK,OAAtC,EAA+C;AAC3C,QAAIC,MAAM,CAACC,IAAP,CAAYC,QAAZ,IAAwBF,MAAM,CAACC,IAAP,CAAYC,QAAZ,CAAqBC,MAAjD,EAAyD;AACrD;AACA,YAAMC,cAAc,GAAGJ,MAAM,CAACC,IAAP,CAAYC,QAAZ,CAAqBG,MAArB,CAA4BC,CAAC,IAAI,EAAEA,CAAC,CAACd,OAAF,YAAqBe,IAAvB,CAAjC,CAAvB;AACA,YAAMC,WAAW,GAAGR,MAAM,CAACC,IAAP,CAAYC,QAAZ,CAAqBG,MAArB,CAA4BC,CAAC,IAAIA,CAAC,CAACd,OAAF,YAAqBe,IAAtD,CAApB;AAEA,aAAOrB,OAAO,CAACuB,GAAR,CAAYD,WAAW,CAACE,GAAZ,CAAgB1B,mBAAhB,CAAZ,EACF2B,IADE,CACGC,cAAc,IAAIA,cAAc,CAACF,GAAf,CAAmBG,SAAS,KAAK;AACrDC,QAAAA,GAAG,EAAED,SADgD;AAErDE,QAAAA,KAAK,EAAG,GAAEf,MAAM,CAACC,IAAP,CAAYc,KAAM;AAFyB,OAAL,CAA5B,CADrB,EAKFJ,IALE,CAKGK,sBAAsB,IAAInB,cAAc,CAACC,IAAD,EAAOC,QAAP,EAAiB,EAC3D,GAAGC,MADwD;AAE3DC,QAAAA,IAAI,EAAE,EACF,GAAGD,MAAM,CAACC,IADR;AAEFC,UAAAA,QAAQ,EAAE,CAAC,GAAGc,sBAAJ,EAA4B,GAAGZ,cAA/B;AAFR;AAFqD,OAAjB,CAL3C,CAAP;AAYH;AACJ;;AAED,SAAOP,cAAc,CAACC,IAAD,EAAOC,QAAP,EAAiBC,MAAjB,CAArB;AACH,CAvBD;;AAyBA,eAAeJ,qBAAf","sourcesContent":["// import customKeysDataProvider from 'ra-data-rest-client';\r\n// import {fetchUtils} from \"react-admin\";\r\n//\r\n// const httpClient = (url, options = {}) => {\r\n//     if (!options.headers) {\r\n//         options.headers = new Headers({ Accept: '*/*' });\r\n//     }\r\n//     const token = JSON.parse(localStorage.getItem('token'));\r\n//     options.headers.set('Authorization', `Bearer ${token}`);\r\n//     return fetchUtils.fetchJson(url, options);\r\n// };\r\n//\r\n// const customKeysHash = {\r\n//     'products': '_id',\r\n//     'orders': '_id',\r\n//     'users': '_id'\r\n// }\r\n//\r\n// const dataProvider = customKeysDataProvider('http://localhost:5000', customKeysHash, {}, httpClient);\r\n//\r\n// const myDataProvider = {\r\n//     ...dataProvider,\r\n//     post: (resource, params) => {\r\n//         if (resource !== 'products' || !params.models.product.productImage) {\r\n//             // fallback to the default implementation\r\n//             return dataProvider.create(resource, params);\r\n//         }\r\n//         /**\r\n//          * For posts update only, convert uploaded image in base 64 and attach it to\r\n//          * the `picture` sent property, with `src` and `title` attributes.\r\n//          */\r\n//\r\n//             // Freshly dropped pictures are File objects and must be converted to base64 strings\r\n//         const newPictures = params.models.product.productImage.filter(\r\n//             p => p.rawFile instanceof File\r\n//             );\r\n//         const formerPictures = params.models.product.productImage.filter(\r\n//             p => !(p.rawFile instanceof File)\r\n//         );\r\n//\r\n//         return Promise.all(newPictures.map(convertFileToBase64))\r\n//             .then(base64Pictures =>\r\n//                 base64Pictures.map(picture64 => ({\r\n//                     picture64\r\n//                 }))\r\n//             )\r\n//             .then(transformedNewPictures =>\r\n//                 dataProvider.create(resource, {\r\n//                     ...params,\r\n//                     product: {\r\n//                         ...params.product,\r\n//                         productImage: [\r\n//                             ...formerPictures,\r\n//                         ],\r\n//                     },\r\n//                 })\r\n//             );\r\n//     },\r\n// };\r\n//\r\n// /**\r\n//  * Convert a `File` object returned by the upload input into a base 64 string.\r\n//  * That's not the most optimized way to store images in production, but it's\r\n//  * enough to illustrate the idea of data provider decoration.\r\n//  */\r\n// const convertFileToBase64 = file =>\r\n//     new Promise((resolve, reject) => {\r\n//         const reader = new FileReader();\r\n//         reader.onload = () => resolve(reader.result);\r\n//         reader.onerror = reject;\r\n//\r\n//         reader.readAsDataURL(file.rawFile);\r\n//     });\r\n//\r\n// export default myDataProvider;\r\n\r\n\r\n//-----------------------------------------------------------------------------------------------------\r\n/**\r\n * Convert a `File` object returned by the upload input into\r\n * a base 64 string. That's easier to use on FakeRest, used on\r\n * the ng-admin example. But that's probably not the most optimized\r\n * way to do in a production database.\r\n */\r\nconst convertFileToBase64 = file => new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.readAsDataURL(file.rawFile);\r\n\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = reject;\r\n});\r\n\r\n/**\r\n * For posts update only, convert uploaded image in base 64 and attach it to\r\n * the `picture` sent property, with `src` and `title` attributes.\r\n */\r\nconst addUploadCapabilities = requestHandler => (type, resource, params) => {\r\n    if (type === 'UPDATE' && resource === 'posts') {\r\n        if (params.data.pictures && params.data.pictures.length) {\r\n            // only freshly dropped pictures are instance of File\r\n            const formerPictures = params.data.pictures.filter(p => !(p.rawFile instanceof File));\r\n            const newPictures = params.data.pictures.filter(p => p.rawFile instanceof File);\r\n\r\n            return Promise.all(newPictures.map(convertFileToBase64))\r\n                .then(base64Pictures => base64Pictures.map(picture64 => ({\r\n                    src: picture64,\r\n                    title: `${params.data.title}`,\r\n                })))\r\n                .then(transformedNewPictures => requestHandler(type, resource, {\r\n                    ...params,\r\n                    data: {\r\n                        ...params.data,\r\n                        pictures: [...transformedNewPictures, ...formerPictures],\r\n                    },\r\n                }));\r\n        }\r\n    }\r\n\r\n    return requestHandler(type, resource, params);\r\n};\r\n\r\nexport default addUploadCapabilities;"]},"metadata":{},"sourceType":"module"}